///
/// JHybridNitroTextInputViewStateUpdater.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridNitroTextInputViewStateUpdater.hpp"
#include "views/HybridNitroTextInputViewComponent.hpp"
#include <NitroModules/NitroDefines.hpp>

namespace margelo::nitro::nitrotextinput::views {

using namespace facebook;
using ConcreteStateData = react::ConcreteState<HybridNitroTextInputViewState>;

void JHybridNitroTextInputViewStateUpdater::updateViewProps(jni::alias_ref<jni::JClass> /* class */,
                                           jni::alias_ref<JHybridNitroTextInputViewSpec::javaobject> javaView,
                                           jni::alias_ref<JStateWrapper::javaobject> stateWrapperInterface) {
  JHybridNitroTextInputViewSpec* view = javaView->cthis();

  // Get concrete StateWrapperImpl from passed StateWrapper interface object
  jobject rawStateWrapper = stateWrapperInterface.get();
  if (!stateWrapperInterface->isInstanceOf(react::StateWrapperImpl::javaClassStatic())) {
      throw std::runtime_error("StateWrapper is not a StateWrapperImpl");
  }
  auto stateWrapper = jni::alias_ref<react::StateWrapperImpl::javaobject>{
            static_cast<react::StateWrapperImpl::javaobject>(rawStateWrapper)};

  std::shared_ptr<const react::State> state = stateWrapper->cthis()->getState();
  auto concreteState = std::dynamic_pointer_cast<const ConcreteStateData>(state);
  const HybridNitroTextInputViewState& data = concreteState->getData();
  const std::optional<HybridNitroTextInputViewProps>& maybeProps = data.getProps();
  if (!maybeProps.has_value()) {
    // Props aren't set yet!
    throw std::runtime_error("HybridNitroTextInputViewState's data doesn't contain any props!");
  }
  const HybridNitroTextInputViewProps& props = maybeProps.value();
  if (props.allowFontScaling.isDirty) {
    view->setAllowFontScaling(props.allowFontScaling.value);
    // TODO: Set isDirty = false
  }
  if (props.autoCapitalize.isDirty) {
    view->setAutoCapitalize(props.autoCapitalize.value);
    // TODO: Set isDirty = false
  }
  if (props.autoComplete.isDirty) {
    view->setAutoComplete(props.autoComplete.value);
    // TODO: Set isDirty = false
  }
  if (props.autoCorrect.isDirty) {
    view->setAutoCorrect(props.autoCorrect.value);
    // TODO: Set isDirty = false
  }
  if (props.autoFocus.isDirty) {
    view->setAutoFocus(props.autoFocus.value);
    // TODO: Set isDirty = false
  }
  if (props.caretHidden.isDirty) {
    view->setCaretHidden(props.caretHidden.value);
    // TODO: Set isDirty = false
  }
  if (props.clearButtonMode.isDirty) {
    view->setClearButtonMode(props.clearButtonMode.value);
    // TODO: Set isDirty = false
  }
  if (props.clearTextOnFocus.isDirty) {
    view->setClearTextOnFocus(props.clearTextOnFocus.value);
    // TODO: Set isDirty = false
  }
  if (props.contextMenuHidden.isDirty) {
    view->setContextMenuHidden(props.contextMenuHidden.value);
    // TODO: Set isDirty = false
  }
  if (props.defaultValue.isDirty) {
    view->setDefaultValue(props.defaultValue.value);
    // TODO: Set isDirty = false
  }
  if (props.editable.isDirty) {
    view->setEditable(props.editable.value);
    // TODO: Set isDirty = false
  }
  if (props.enablesReturnKeyAutomatically.isDirty) {
    view->setEnablesReturnKeyAutomatically(props.enablesReturnKeyAutomatically.value);
    // TODO: Set isDirty = false
  }
  if (props.enterKeyHint.isDirty) {
    view->setEnterKeyHint(props.enterKeyHint.value);
    // TODO: Set isDirty = false
  }
  if (props.keyboardType.isDirty) {
    view->setKeyboardType(props.keyboardType.value);
    // TODO: Set isDirty = false
  }
  if (props.maxFontSizeMultiplier.isDirty) {
    view->setMaxFontSizeMultiplier(props.maxFontSizeMultiplier.value);
    // TODO: Set isDirty = false
  }
  if (props.maxLength.isDirty) {
    view->setMaxLength(props.maxLength.value);
    // TODO: Set isDirty = false
  }
  if (props.multiline.isDirty) {
    view->setMultiline(props.multiline.value);
    // TODO: Set isDirty = false
  }
  if (props.placeholder.isDirty) {
    view->setPlaceholder(props.placeholder.value);
    // TODO: Set isDirty = false
  }
  if (props.onFocused.isDirty) {
    view->setOnFocused(props.onFocused.value);
    // TODO: Set isDirty = false
  }
  if (props.onBlurred.isDirty) {
    view->setOnBlurred(props.onBlurred.value);
    // TODO: Set isDirty = false
  }
  if (props.onTextChanged.isDirty) {
    view->setOnTextChanged(props.onTextChanged.value);
    // TODO: Set isDirty = false
  }
  if (props.onEditingEnded.isDirty) {
    view->setOnEditingEnded(props.onEditingEnded.value);
    // TODO: Set isDirty = false
  }
  if (props.onTouchBegan.isDirty) {
    view->setOnTouchBegan(props.onTouchBegan.value);
    // TODO: Set isDirty = false
  }
  if (props.onTouchEnded.isDirty) {
    view->setOnTouchEnded(props.onTouchEnded.value);
    // TODO: Set isDirty = false
  }
  if (props.onInitialHeightMeasured.isDirty) {
    view->setOnInitialHeightMeasured(props.onInitialHeightMeasured.value);
    // TODO: Set isDirty = false
  }

  // Update hybridRef if it changed
  if (props.hybridRef.isDirty) {
    // hybridRef changed - call it with new this
    const auto& maybeFunc = props.hybridRef.value;
    if (maybeFunc.has_value()) {
      std::shared_ptr<JHybridNitroTextInputViewSpec> shared = javaView->cthis()->shared_cast<JHybridNitroTextInputViewSpec>();
      maybeFunc.value()(shared);
    }
    // TODO: Set isDirty = false
  }
}

} // namespace margelo::nitro::nitrotextinput::views
