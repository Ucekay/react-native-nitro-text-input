///
/// HybridNitroTextInputViewComponent.mm
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#import "HybridNitroTextInputViewComponent.hpp"
#import <memory>
#import <react/renderer/componentregistry/ComponentDescriptorProvider.h>
#import <React/RCTViewComponentView.h>
#import <React/RCTComponentViewFactory.h>
#import <React/UIView+ComponentViewProtocol.h>
#import <NitroModules/NitroDefines.hpp>
#import <UIKit/UIKit.h>

#import "HybridNitroTextInputViewSpecSwift.hpp"
#import "NitroTextInput-Swift-Cxx-Umbrella.hpp"

using namespace facebook;
using namespace margelo::nitro::nitrotextinput;
using namespace margelo::nitro::nitrotextinput::views;

/**
 * Represents the React Native View holder for the Nitro "NitroTextInputView" HybridView.
 */
@interface HybridNitroTextInputViewComponent: RCTViewComponentView
@end

@implementation HybridNitroTextInputViewComponent {
  std::shared_ptr<HybridNitroTextInputViewSpecSwift> _hybridView;
}

+ (void) load {
  [super load];
  [RCTComponentViewFactory.currentComponentViewFactory registerComponentViewClass:[HybridNitroTextInputViewComponent class]];
}

+ (react::ComponentDescriptorProvider) componentDescriptorProvider {
  return react::concreteComponentDescriptorProvider<HybridNitroTextInputViewComponentDescriptor>();
}

- (instancetype) init {
  if (self = [super init]) {
    std::shared_ptr<HybridNitroTextInputViewSpec> hybridView = NitroTextInput::NitroTextInputAutolinking::createNitroTextInputView();
    _hybridView = std::dynamic_pointer_cast<HybridNitroTextInputViewSpecSwift>(hybridView);
    [self updateView];
  }
  return self;
}

- (void) updateView {
  // 1. Get Swift part
  NitroTextInput::HybridNitroTextInputViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Get UIView*
  void* viewUnsafe = swiftPart.getView();
  UIView* view = (__bridge_transfer UIView*) viewUnsafe;

  // 3. Update RCTViewComponentView's [contentView]
  [self setContentView:view];
}

- (void) updateProps:(const std::shared_ptr<const react::Props>&)props
            oldProps:(const std::shared_ptr<const react::Props>&)oldProps {
  // 1. Downcast props
  const auto& newViewPropsConst = *std::static_pointer_cast<HybridNitroTextInputViewProps const>(props);
  auto& newViewProps = const_cast<HybridNitroTextInputViewProps&>(newViewPropsConst);
  NitroTextInput::HybridNitroTextInputViewSpec_cxx& swiftPart = _hybridView->getSwiftPart();

  // 2. Update each prop individually
  swiftPart.beforeUpdate();

  // allowFontScaling: optional
  if (newViewProps.allowFontScaling.isDirty) {
    swiftPart.setAllowFontScaling(newViewProps.allowFontScaling.value);
    newViewProps.allowFontScaling.isDirty = false;
  }
  // autoCapitalize: optional
  if (newViewProps.autoCapitalize.isDirty) {
    swiftPart.setAutoCapitalize(newViewProps.autoCapitalize.value);
    newViewProps.autoCapitalize.isDirty = false;
  }
  // autoComplete: optional
  if (newViewProps.autoComplete.isDirty) {
    swiftPart.setAutoComplete(newViewProps.autoComplete.value);
    newViewProps.autoComplete.isDirty = false;
  }
  // autoCorrect: optional
  if (newViewProps.autoCorrect.isDirty) {
    swiftPart.setAutoCorrect(newViewProps.autoCorrect.value);
    newViewProps.autoCorrect.isDirty = false;
  }
  // autoFocus: optional
  if (newViewProps.autoFocus.isDirty) {
    swiftPart.setAutoFocus(newViewProps.autoFocus.value);
    newViewProps.autoFocus.isDirty = false;
  }
  // caretHidden: optional
  if (newViewProps.caretHidden.isDirty) {
    swiftPart.setCaretHidden(newViewProps.caretHidden.value);
    newViewProps.caretHidden.isDirty = false;
  }
  // clearButtonMode: optional
  if (newViewProps.clearButtonMode.isDirty) {
    swiftPart.setClearButtonMode(newViewProps.clearButtonMode.value);
    newViewProps.clearButtonMode.isDirty = false;
  }
  // clearTextOnFocus: optional
  if (newViewProps.clearTextOnFocus.isDirty) {
    swiftPart.setClearTextOnFocus(newViewProps.clearTextOnFocus.value);
    newViewProps.clearTextOnFocus.isDirty = false;
  }
  // contextMenuHidden: optional
  if (newViewProps.contextMenuHidden.isDirty) {
    swiftPart.setContextMenuHidden(newViewProps.contextMenuHidden.value);
    newViewProps.contextMenuHidden.isDirty = false;
  }
  // defaultValue: optional
  if (newViewProps.defaultValue.isDirty) {
    swiftPart.setDefaultValue(newViewProps.defaultValue.value);
    newViewProps.defaultValue.isDirty = false;
  }
  // editable: optional
  if (newViewProps.editable.isDirty) {
    swiftPart.setEditable(newViewProps.editable.value);
    newViewProps.editable.isDirty = false;
  }
  // enablesReturnKeyAutomatically: optional
  if (newViewProps.enablesReturnKeyAutomatically.isDirty) {
    swiftPart.setEnablesReturnKeyAutomatically(newViewProps.enablesReturnKeyAutomatically.value);
    newViewProps.enablesReturnKeyAutomatically.isDirty = false;
  }
  // enterKeyHint: optional
  if (newViewProps.enterKeyHint.isDirty) {
    swiftPart.setEnterKeyHint(newViewProps.enterKeyHint.value);
    newViewProps.enterKeyHint.isDirty = false;
  }
  // keyboardType: optional
  if (newViewProps.keyboardType.isDirty) {
    swiftPart.setKeyboardType(newViewProps.keyboardType.value);
    newViewProps.keyboardType.isDirty = false;
  }
  // maxFontSizeMultiplier: optional
  if (newViewProps.maxFontSizeMultiplier.isDirty) {
    swiftPart.setMaxFontSizeMultiplier(newViewProps.maxFontSizeMultiplier.value);
    newViewProps.maxFontSizeMultiplier.isDirty = false;
  }
  // maxLength: optional
  if (newViewProps.maxLength.isDirty) {
    swiftPart.setMaxLength(newViewProps.maxLength.value);
    newViewProps.maxLength.isDirty = false;
  }
  // multiline: optional
  if (newViewProps.multiline.isDirty) {
    swiftPart.setMultiline(newViewProps.multiline.value);
    newViewProps.multiline.isDirty = false;
  }
  // placeholder: optional
  if (newViewProps.placeholder.isDirty) {
    swiftPart.setPlaceholder(newViewProps.placeholder.value);
    newViewProps.placeholder.isDirty = false;
  }
  // onTextChanged: optional
  if (newViewProps.onTextChanged.isDirty) {
    swiftPart.setOnTextChanged(newViewProps.onTextChanged.value);
    newViewProps.onTextChanged.isDirty = false;
  }
  // onBlurred: optional
  if (newViewProps.onBlurred.isDirty) {
    swiftPart.setOnBlurred(newViewProps.onBlurred.value);
    newViewProps.onBlurred.isDirty = false;
  }
  // onInitialHeightMeasured: optional
  if (newViewProps.onInitialHeightMeasured.isDirty) {
    swiftPart.setOnInitialHeightMeasured(newViewProps.onInitialHeightMeasured.value);
    newViewProps.onInitialHeightMeasured.isDirty = false;
  }

  swiftPart.afterUpdate();

  // 3. Update hybridRef if it changed
  if (newViewProps.hybridRef.isDirty) {
    // hybridRef changed - call it with new this
    const auto& maybeFunc = newViewProps.hybridRef.value;
    if (maybeFunc.has_value()) {
      maybeFunc.value()(_hybridView);
    }
    newViewProps.hybridRef.isDirty = false;
  }

  // 4. Continue in base class
  [super updateProps:props oldProps:oldProps];
}

@end
